# 생성자함수

📕 : https://www.notion.so/fun-blog/17-7e53e076305e486ba3a8d7e747e8a634<br>

- 생성자 함수란?
  new연산자와 함께 호출하여 인스턴스를 생성하는 함수다.
- 생성자함수로 객체를 만드는 이유는?
  생성자 함수는 객체를 생성하기 위한 템플릿과 같다. 하나의 생성자 함수를 만들어놓으면 프로퍼티 구조가 같은 동일한 객체를 여러개 생성할 수 있다.
- 생성자 함수의 역할은?
  - 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작한다.
  - 인스턴스를 생성하고 초기화하는 것이다.
- 객체 리터럴로 객체를 만드는 것과 생성자함수로 객체를 만드는 것의 장단점은 무엇인가?
  - 객체 리터럴로 객체를 생성하는 것
    - 장점 : 객체 리터럴로 객체를 생성하는 것은 직관적이고 간편하다.
    - 단점 : 단 하나의 객체만 생성이 가능하다는 점이다. 동일한 프로퍼티를 갖지만 값이 다르다면 객체 리터럴로 매번 동일한 프로퍼티를 작성해야 하기 때문에 비효율적이다.
  - 생성자 함수로 객체를 생성하는 것
    - 장점 : 생성자 함수는 인스턴스를 만드는 템플릿과 같은 역할을 한다. 프로퍼티 구조가 동일한 객체를 여러개 만들 수 있다.
- 생성자 함수의 인스턴스 생성과정
  - 인스턴스 생성하고 this를 바인딩한다.
    생성자함수로 인스턴스를 생성하면 빈 객체가 만들어진다.
    이후 this는 빈 객체에 바인딩되어 인스턴스와 this의 연결이 이루어진다.
  - 인스턴스를 초기화한다.
    생성자 함수에 있는 프로퍼티와 메서드를 this가 바인딩한다.
    생성자 함수의 인수로 전달받은 값을 인스턴스 프로퍼티에 할당한다.
  - 인스턴스를 반환한다.
    모든 처리가 끝나면 인스턴스의 this가 암묵적으로 반환된다
        ```jsx
        function Circle(radius) {
          // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.

          // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
          this.radius = radius;
          this.getDiameter = function () {
            return 2 * this.radius;
          };

          // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다
        }

        // 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.
        const circle = new Circle(1);
        console.log(circle); // Circle {radius: 1, getDiameter: ƒ}
        ```
- construntor와 non-constructor의 차이는 무엇인가 ?
  함수 정의 방식에 따라 constructor와 non-constructor를 구분한다.
  - constructor
    - 함수 선언문, 함수 표현식, 클래식으로 생성한 함수를 뜻한다.
    - 생성자 함수로서 [[constructor]] 메서드가 호출된다.
      [[constructor]]메서드는 생성자 함수 객체를 생성하고 초기화하는 역할을 한다.
  - non-constructor
    - 화살표 함수로 생성한 함수를 뜻한다
    - [[call]] 메서드가 호출된다. [[constructor]] 메서드를 갖지 않기 때문에 생성자 함수로서 호출하면 에러가 발생한다.
- this는 무엇인가? , this 바인딩이란 무엇인가?
  - this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기참조변수이다.
  - this바인딩은 함수를 호출할 때, 함수 내부에서 사용되는 this가 어떤 객체를 가리키는 값이다. this바인딩은 함수 호출 방식에 따라서 동적으로 결정된다.
    1. 일반 함수 호출: 전역 객체를 참조합니다. (strict mode에서는 undefined를 참조합니다.)
    2. 객체의 메소드 호출: 해당 메소드를 호출한 객체를 참조합니다.
    3. 생성자 함수 호출: 생성된 객체를 참조합니다.
    4. call 또는 apply 메소드를 사용한 간접 호출: 지정한 객체를 참조합니다.
  **`this`** 바인딩은 함수 호출 시점에 동적으로 결정되기 때문에, 함수가 호출되는 방식에 따라 참조하는 객체가 달라질 수 있습니다. 이러한 동적인 **`this`** 바인딩은 자바스크립트에서 함수의 유연한 사용을 가능하게 합니다.
- _new 연산자를 이용해 생성자함수를 실행하는 것과 new 연산 없이 함수를 실행하는 것은 어떤 차이가 있나요?_
  (1) **`new`** 키워드를 사용하여 생성자 함수를 호출하면, 새로운 객체가 생성되고 그 객체의 프로토타입이 생성자 함수의 프로토타입과 연결됩니다. 그리고 생성자 함수 내부의 **`this`**는 새로 생성된 객체를 참조하게 됩니다. 따라서, 생성자 함수 내부에서 **`this`**를 사용하여 프로퍼티를 추가하거나 메소드를 정의하면, 생성된 객체에 그 값이 추가되며, 생성된 객체를 반환합니다.
  반면에, 일반적인 함수를 호출할 때는 새로운 객체가 생성되지 않고, 함수의 내부에서 **`this`**는 전역 객체를 참조하게 됩니다. 따라서, 함수 내부에서 **`this`**를 사용하여 프로퍼티를 추가하거나 메소드를 정의하면, 전역 객체에 그 값이 추가되며, 반환값은 명시적으로 지정하지 않는 한 **`undefined`**가 됩니다.
- _생성자 함수를 생성할 때 프로토타입과 연결된다. 이때 프로토타입은 무엇인가 ?_
  프로토타입은 객체를 생성할 때 생성자 함수와 함께 만들어지는 객체의 일종으로, 다른 객체의 원형이 되는 객체입니다. 생성자 함수를 정의하면서 해당 생성자 함수의 **`prototype`** 프로퍼티에 프로토타입 객체를 할당하면, 생성자 함수로부터 생성된 모든 객체는 그 프로토타입 객체를 상속받습니다.
  프로토타입 객체는 일반 객체와 마찬가지로 속성을 가질 수 있습니다. 그리고 생성자 함수로부터 생성된 모든 객체는 프로토타입 객체의 속성을 자신의 속성처럼 사용할 수 있습니다. 이를 통해, 생성자 함수로부터 생성된 객체들 간에 코드를 공유하고, 중복되는 코드를 줄일 수 있습니다.
