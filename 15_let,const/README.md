### var키워드로 선언한 변수의 문제점

- **중복선언이 가능**하기 때문에, 의도치 않게 변수가 재선언되어 값이 바뀔 수 있다.
- **함수레벨 스코프**를 가지고 있어, 함수스코프 외에서 변수를 선언하면 모두 전역변수가 된다. 이로 인해 함수 스코프 외의 모든 변수는 재선언 되어 값이 변경될 수 있는 위험이 있다.
- **변수 호이스팅이 일어나고 변수에 값이 할당되기 전까지 undefined의 값을 반환한다**. var키워드의 호이스팅은 가독성을 떨어뜨리고, 오류 발생의 여지를 남긴다.

### let 키워드

- 변수 중복 선언 금지
- 블록레벨 스코프를 가지고 있어 함수, if문, for문 등의 모든 코드블록을 지역스코프로 인정한다.
- 변수호이스팅, TDZ
let으로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다. 초기화 단계 전에 let으로 선언한 변수를 참조하려고 하면 typeError가 발생한다. 선언과 초기화 사이의 변수를 참조할 수 없는 부분을 TDZ 일시적 사각지대라고 부른다.
    - TDZ는 코드의 가독성을 향상시킨다. 변수가 초기화 되기 전에 변수를 사용하려고 하면 코드의 흐름을 이해하기 어려울 수 있다. 그렇기 때문에 변수가 사용 가능할 때까지 에러를 발생시켜 변수를 사용하지 않도록 도와준다.?ㅋ
- let키워드로 선언한 전역변수는 전역객체의 프로퍼티가 아니다. let으로 선언한 전역 변수는 보이지 않는 블록 내에 존재하게 된다.

### const 키워드

- 상수를 선언하기 위해 사용한다. 이 때 선언과 동시에 초기화를 해야 한다.
    
    ```jsx
    const foo = 1 
    const foo // SyntaxError
    ```
    
- 블록레벨스코프를 가지며, let과 같은 변수 호이스팅이 발생하고, TDZ를 가지고 있다
- const는 재할당을 금지한다. ( = 불변을 의미하지는 않는다 )
원시값은 변수에 재할당을 해야 하므로 값을 바꿀 수 없지만, 객체는 변수의 재할당 없이도 값을 바꿀 수 있기 때문에 const로 선언했어도 값을 바꿀 수 있다.
    - const로 선언한 변수에 원시값을 할당한 경우 : 원시값을 변경할 수 없다.
    원시값은 변경할 수 없는 값이다. 원시값을 변경하기 위해서는 재할당이 이루어져야 하는데, const 키워드는 재할당이 불가능하므로, 원시값이 할당된 변수에서는 값을 변경할 수 없다.
    - const로 선언한 변수에 객체값을 할당한 경우 : 객체값을 변경할 수 있다.
    객체는 프로퍼티를 동적으로 추가, 삭제 하여 변경할 수 있는 값이다. 변수 (메모리공간)를 재할당 하지 않고도 값을 변경할 수 있다.