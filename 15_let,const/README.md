## 정리
### var키워드로 선언한 변수의 문제점
- **중복선언이 가능**하기 때문에, 의도치 않게 변수가 재선언되어 값이 바뀔 수 있다.
- **함수레벨 스코프**를 가지고 있어, 함수스코프 외에서 변수를 선언하면 모두 전역변수가 된다. 이로 인해 함수 스코프 외의 모든 변수는 재선언 되어 값이 변경될 수 있는 위험이 있다.
- **변수 호이스팅이 일어나고 변수에 값이 할당되기 전까지 undefined의 값을 반환한다**. var키워드의 호이스팅은 가독성을 떨어뜨리고, 오류 발생의 여지를 남긴다.
<br> 

### let 키워드
- 변수 중복 선언 금지
- 블록레벨 스코프를 가지고 있어 함수, if문, for문 등의 모든 코드블록을 지역스코프로 인정한다.
- 변수호이스팅, TDZ
let으로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다. 초기화 단계 전에 let으로 선언한 변수를 참조하려고 하면 typeError가 발생한다. 선언과 초기화 사이의 변수를 참조할 수 없는 부분을 TDZ 일시적 사각지대라고 부른다.
    - TDZ는 코드의 가독성을 향상시킨다. 변수가 초기화 되기 전에 변수를 사용하려고 하면 코드의 흐름을 이해하기 어려울 수 있다. 그렇기 때문에 변수가 사용 가능할 때까지 에러를 발생시켜 변수를 사용하지 않도록 도와준다.?ㅋ
- let키워드로 선언한 전역변수는 전역객체의 프로퍼티가 아니다. let으로 선언한 전역 변수는 보이지 않는 블록 내에 존재하게 된다.
<br>

### const 키워드
- 상수를 선언하기 위해 사용한다. 이 때 선언과 동시에 초기화를 해야 한다.
    
    ```jsx
    const foo = 1 
    const foo // SyntaxError
    ```
    
- 블록레벨스코프를 가지며, let과 같은 변수 호이스팅이 발생하고, TDZ를 가지고 있다
- const는 재할당을 금지한다. ( = 불변을 의미하지는 않는다 )
원시값은 변수에 재할당을 해야 하므로 값을 바꿀 수 없지만, 객체는 변수의 재할당 없이도 값을 바꿀 수 있기 때문에 const로 선언했어도 값을 바꿀 수 있다.
    - const로 선언한 변수에 원시값을 할당한 경우 : 원시값을 변경할 수 없다.
    원시값은 변경할 수 없는 값이다. 원시값을 변경하기 위해서는 재할당이 이루어져야 하는데, const 키워드는 재할당이 불가능하므로, 원시값이 할당된 변수에서는 값을 변경할 수 없다.
    - const로 선언한 변수에 객체값을 할당한 경우 : 객체값을 변경할 수 있다.
    객체는 프로퍼티를 동적으로 추가, 삭제 하여 변경할 수 있는 값이다. 변수 (메모리공간)를 재할당 하지 않고도 값을 변경할 수 있다.
<br>

## Q. 
- var키워드로 변수를 선언했을 때의 문제점<br>

    - 중복선언이 가능하기 때문에 의도치 않게 변수의 값이 바뀔 수 있다
    - 함수레벨 스코프를 따르고 있기 때문에 함수 외의 변수가 선언되었을 경우에는 모두 전역변수로 인식된다. 중복선언이 가능한 var는 의도치 않게 값을 바꿀 수 있다
    - 변수 호이스팅이 일어나 선언과 초기화가 동시에 발생한다. <br>
      할당이 되기 전에 var변수를 참조하면 undefined가 출력되는데, 이는 코드의 가독성을 떨어뜨리고, 오류 발생의 여지를 남긴다<br>
      <br>
    
- let 키워드의 특징<br>

    - 변수 중복 선언 금지, 블록레벨 스코프를 가지고, TDZ를 가진다.
    - let키워드로 선언한 전역변수는 전역객체의 프로퍼티가 아니다.
    = 전역객체와 같은 스코프체인 상에 존재하지 않는다. 보이지 않는 개념적인 블록 내에 존재한다
    <br>
    
- const키워드의 특징<br>

    - 상수를 선언하는 변수이다. 선언과 동시에 초기화가 이루어져야 한다.
    - let과 같이 블록레벨 스코프를 따르고 있고, TDZ를 가지고 있다.
    - 재할당이 금지된 변수이나, 이는 아예 값을 바꿀 수 없다는 뜻은 아니다.
        - const 키워드로 선한 변수에 원시값이 있는 경우에는 값을 바꿀 때 변수를 재할당 해야 하기 때문에 const키워드는 이를 금지한다. 
        하지만 객체값이 들어있는 경우는 변수를 재할당 하지 않고, 변수 안에 저장된 참조값을 통해서 값에 직접 접근해 객체를 수정할 수 있으므로 객체는 값을 바꿀 수 있다.
        
    
