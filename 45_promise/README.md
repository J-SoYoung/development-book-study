# Promise
ES6에서는 비동기 처리를 위한 패턴으로 프로미스를 도입했다. 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

## 비동기 처리를 위한 콜백 패턴의 단점

비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 하더라도 기다리지 않고 즉시 종료된다. 따라서 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프 변수에 할당하면 기대한 대로 동작하지 않는다. 

```jsx
let todos;

// GET 요청을 위한 비동기 함수
const get = url => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      // ① 서버의 응답을 상위 스코프의 변수에 할당한다.
      todos = JSON.parse(xhr.response);
    } else {
      console.error(`${xhr.status} ${xhr.statusText}`);
    }
  };
};

// id가 1인 post를 취득
get('https://jsonplaceholder.typicode.com/posts/1');
console.log(todos); // ② undefined
```

코드를 보아 예상 결과로는 get요쳥 후 결과값을 todos에 할당하고, 할당된 todos를 콘솔에서 확인할 수 있게 된다. 하지만 예상했던 결과가 아닌 콘솔의 값은 undefined이다. 왜일까?

xhr.onload 이벤트 핸들러 프로퍼티에 바인딩한 이벤트 핸들러는 console.log가 종료된 이후에 호출된다. 그렇기 때문에 todos를 출력해보면 아직 onload의 이벤트 핸들러의 결과가 나오지 않았기 때문에 undefined가 출력되는 것이다. 

get함수에 등록된 이벤트 핸들러는 get함수의 실행과 동시에 실행되는 것이 아니다. get함수를 실행하고 비동기 함수인 onload이벤트 핸들러는 태스크 큐에 저장되고, 다음 코드로 넘어간다. console.log의 실행이 끝나고 나면 콜스택이 비게 되고, 이벤트 루프에 의해 콜스택으로 푸시되어 실행된다. 따라서, onload이벤트 핸들러에서 서버 응답을 상위 스코프 변수에 할당하면 처리 순서가 보장되지 않는다.

이처럼 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프 변수에 할당할 수도 없다. 비동기 함수의 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다. 그 방법으로 비동기 처리 결과에 따른 콜백함수를 전달하는 것이 일반적이다. 

### (1) 콜백 헬 Callback Hell

비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수의 값을 이용하여 또 다른 처리를 해야 한다면 콜백함수의 호출이 중첩되어 복잡도가 높아지는 현상이 발생한다. 이를 콜백 헬이라고 한다.

### (2) 에러 처리의 한계

```jsx
try {
  setTimeout(() => { throw new Error('Error!'); }, 1000);
} catch (e) {
  // 에러를 캐치하지 못한다
  console.error('캐치한 에러', e);
}
```

setTimeout함수는 비동기 함수이다. setTiemout함수의 실행 시점과, 그 안에 콜백함수의 실행 시점이 다르다. 

setTimeout 은 비동기 함수야. setTimeout함수가 실행되면 실행 컨텍스트가 생성돼 콜스택에 setTimeout함수가 푸시되어 실행된다. 그 안에 콜백함수는 바로 실행되지 않고 태스크 큐에 저장돼 있다가 setTimeout함수가 끝나고 콜스택이 비면 이벤트 루프가 콜백함수를 콜스택으로 푸시해주어 콜백함수가 실행된다. 

에러는 호출자 방향으로 전파된다. setTimeout의 콜백함수에 에러코드는 자신을 호출한 방향으로 에러를 찾게 된다. 하지만 setTimeout은 이미 실행이 끝나버린 상황이므로 에러를 캐치하지 못하게 되는 것이다.

이의 해결방법으로는 콜백함수 안에 try-catch문을 작성하여 콜백함수에 대한 에러문을 작성해주면 된다. 위처럼 간단한 비동기코드는 문제가 없어 보이지만 콜백이 중첩되는 상황에서의 해당 콜백마다 에러 처리를 해주어야 하기 때문에 비동기 처리를 위한 콜백함수의 에러 처리는 굉장히 까다롭다고 볼 수 있을 것 같다.
---

## 프로미스의 생성