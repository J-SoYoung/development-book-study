## Q. 원시,객체타입

- 원시타입의 값은 ( ) 값이다. 원시값 자체는 ( ) 하지만 변수는 언제든지  
  ( ) 을 통해 변경할 수 있다. 재할당으로 변수를 변경할 수 있지만 새로운 메모리 공간에 데이터가 저장되는 것이지 ( )이 바뀌는 것은 아니다.
      변경 불가능immutable한, 재할당, 원시값
- 상수 const 는 ( )이 금지된 변수이다.
  단 한번만 할당이 허용되므로 ( )을 변경할 수 없다. 그러므로 상수의 ( ) 금지와 원시타입의 ( )값은 같은 뜻이 아니다.
      재할당, 변수값, 재할당, 변경 불가능한
- 변수에 변수를 할당할 때,
  (1)원시값이 저장된 변수와 (2)객체값이 저장된 변수의 특에 대해 설명하시오.
      ```jsx
      // 원시값이 저장된 변수
      var score = 80;
      var copy = score;
      console.log(score, copy);    // 80  80

      score = 100;
      console.log(score, copy);    // 100  80
      console.log(score === copy); // false답
      ```

      - 답


          | 원시타입 | 객체타입 |
          | --- | --- |
          | 변경 불가능한 값이다 | 변경 가능한 값이다 |
          | 변수에 실제 값이 저장된다 | 변수에 참조값 ( 메모리 주소 )이 저장된다 |
          | 값에 의한 전달
          원시값을 가진 변수는 원본의 값이 복사되어 새로운 메모리에 저장된다. ( 값의 형태는 같아도 각각의 메모리에 저장된 다른 데이터다 ) | 참조에 의한 전달
          객체 값을 가진 변수는 원본의 참조값이 복사
           = 두 변수값은 하나의 원본값을 공유하고 있다.   |


---

- 변수에 객체를 할당하면 어떤 값이 저장되는가?
  변수는 객체가 저장된 메모리 주소를 저장한다.
- 객체가 저장된 변수의 값을 수정하면, 자바스크립트는 변수를 재할당 한다. ( O X ) 이유는?
  X , 객체를 저장한 변수는 메모리 주소를 저장하고 있기 때문에 그 안의 값을 수정한다고 해서 메모리 주소가 바뀐 것이 아니기 때문에 객체가 저장된 변수가 수정된 것이 아니다. ⇒ 재할당 없이 객체 값을 변경할 수 있다.  

- 콘솔의 결과가 나오는 이유를 설명해보시오
  (1) c1과 o의 형태는 같지만 ===일치비교 연산자의 결과를 보면 false가 나온다. 이유는?
  (2) 객체 안의 값을 확인해보면 두 객체가 참조하고 있는 값은 true로 나온다. 이유는 ?

```jsx
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log("o-", o); // { x: { y: 1 } }
console.log("c1-", c1); // { x: { y: 1 } }
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
```

- 답
  - (1) 객체를 할당한 변수를 다른 변수에 할당하는 경우, 참조값(메모리 주소)이 복사되어 새로운 변수인 c1에 할당된다. o와 c1은 각각 새로운 변수(메모리 공간)에 객체의 메모리 주소가 저장된 것이기 때문에 false가 맞음
  - (2) c1과 o는 객체의 메모리 주소값을 각각의 변수에 저장하고 있지만, 변수에 저장된 메모리 주소 안의 값은 하나로 연결되어 공유되기 때문에 true가 나오는 것이다.

---
