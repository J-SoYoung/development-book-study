## Q. 원시,객체타입

- 원시타입의 값은 ( ) 값이다. <br>
  원시값 자체는 ( ) 하지만 변수는 언제든지( ) 을 통해 변경할 수 있다.<br>
  재할당으로 변수를 변경할 수 있지만 새로운 메모리 공간에 데이터가 저장되는 것이지 ( )이 바뀌는 것은 아니다.<br>
  답: 변경 불가능immutable한, 재할당, 원시값<br>
  <br>
  
- 상수 const 는 ( )이 금지된 변수이다.<br>
  단 한번만 할당이 허용되므로 ( )을 변경할 수 없다. <br>
  그러므로 상수의 ( ) 금지와 원시타입의 ( )값은 같은 뜻이 아니다.
  답: 재할당, 변수값, 재할당, 변경 불가능한<br>
<br>

- 변수에 변수를 할당할 때,<br>
  (1)원시값이 저장된 변수와 (2)객체값이 저장된 변수의 특에 대해 설명하시오.
  ```
  // 원시값이 저장된 변수
  var score = 80;
  var copy = score;
  console.log(score, copy);    // 80  80

  score = 100;
  console.log(score, copy);    // 100  80
  console.log(score === copy); // false답
  ```
답 : 
< 원시타입 > : 변경 불가능한 값이다, 변수에 실제 값이 저장된다<br>
  값에 의한 전달: 원시값을 가진 변수는 원본의 값이 복사되어 새로운 메모리에 저장된다.<br>
  ( 값의 형태는 같아도 각각의 메모리에 저장된 다른 데이터다 )<br> 
< 객체타입 > : 변경 가능한 값이다, 변수에 참조값 (메모리 주소)이 저장된다<br>
  참조에 의한 전달 : 객체 값을 가진 변수는 원본의 참조값이 복사 = 두 변수값은 하나의 원본값을 공유하고 있다.<br>
  <br>

- 변수에 객체를 할당하면 어떤 값이 저장되는가? <br>
  답: 변수는 객체가 저장된 메모리 주소를 저장한다.<br>
  <br>
  
- 객체가 저장된 변수의 값을 수정하면, 자바스크립트는 변수를 재할당 한다. ( O X ) 이유는?<br>
  X , 객체를 저장한 변수는 메모리 주소를 저장하고 있기 때문에 그 안의 값을 수정한다고 해서 메모리 주소가 바뀐 것이 아니다<br>
  이 때문에 객체가 저장된 변수가 수정된 것이 아니다. ⇒ 재할당 없이 객체 값을 변경할 수 있다. <br>
  <br>

- 콘솔의 결과가 나오는 이유를 설명해보시오<br>
  (1) c1과 o의 형태는 같지만 ===일치비교 연산자의 결과를 보면 false가 나온다. 이유는?<br>
  (2) 객체 안의 값을 확인해보면 두 객체가 참조하고 있는 값은 true로 나온다. 이유는 ?<br>

  ```
  const o = { x: { y: 1 } };

  // 얕은 복사
  const c1 = { ...o };
  console.log("o-", o); // { x: { y: 1 } }
  console.log("c1-", c1); // { x: { y: 1 } }
  console.log(c1 === o); // false
  console.log(c1.x === o.x); // true
  ```

답: 
  - (1) 객체를 할당한 변수를 다른 변수에 할당하는 경우,<br>
    참조값(메모리 주소)이 복사되어 새로운 변수인 c1에 할당된다.<br>
    o와 c1은 각각 새로운 변수(메모리 공간)에 객체의 메모리 주소가 저장된 것이기 때문에 false가 맞음
  - (2) c1과 o는 객체의 메모리 주소값을 각각의 변수에 저장하고 있지만, <br>
    변수에 저장된 메모리 주소 안의 값은 하나로 연결되어 공유되기 때문에 true가 나오는 것이다.

