## Q. 
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log('o-', o)    // { x: { y: 1 } }
console.log('c1-', c1)  // { x: { y: 1 } }
console.log(c1 === o);  // false 
console.log(c1.x === o.x); // true

- c1과 o의 형태는 같지만 ===일치비교 연산자의 결과를 보면 false가 나온다. 이유는 무엇인가? 
객체를 할당한 변수를 다른 변수에 할당하는 경우, 참조값(메모리 주소)이 복사되어 새로운 변수인 c1에 할당된다. o와 c1은 각각 새로운 변수(메모리 공간)에 객체의 메모리 주소가 저장된 것이다.
- 하지만 객체 안의 값을 확인해보면 두 객체가 참조하고 있는 값은 true로 나온다, 이유는 ?
c1과 o는 객체의 메모리 주소값을 각각의 변수에 저장하고 있지만, 변수에 저장된 메모리 주소 안의 값은 하나로 연결되어 공유되기 때문에 true가 나오는 것이다. 객체의 실제 값을 수정하면, 객체의 주소값을 공유하고 있는 변수들의 값도 같이 수정된다.